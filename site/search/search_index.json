{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to liionpack For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to liionpack"},{"location":"#welcome-to-liionpack","text":"For full documentation visit mkdocs.org .","title":"Welcome to liionpack"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"liionpack is currently in beta testing","title":"About"},{"location":"code%20of%20conduct/","text":"","title":"Code of conduct"},{"location":"contributing/","text":"","title":"Contributing"},{"location":"reference/","text":"======= liionpack ======= liionpack is a tool for simulating battery packs with pybamm. It can design the pack with a combination of batteries connected in series and parallel or can read a netlist. batteryrig_utils Created on Tue Feb 23 14:57:53 2021 @author: dominicdathan cell_scatter_plot ( ax , c , val_text = False , cellno_text = False , batch_col = False , text_prec = 1 , ** kwargs ) Parameters ax : matplotlib axis obj axis to plot on. c : like plt.scatter c kwarg colors to plot scatter with. val_text : bool write values on plot cellno_text : bool write cell numbers on plot batch_col : color cells by batch text_prec : int precsition to write text of values on cells. **kwargs : plt.scatter kwargs. Returns None. Source code in liionpack\\batteryrig_utils.py def cell_scatter_plot ( ax , c , val_text = False , cellno_text = False , batch_col = False , text_prec = 1 , ** kwargs ): \"\"\" Parameters ---------- ax : matplotlib axis obj axis to plot on. c : like plt.scatter c kwarg colors to plot scatter with. val_text : bool write values on plot cellno_text : bool write cell numbers on plot batch_col : color cells by batch text_prec : int precsition to write text of values on cells. **kwargs : plt.scatter kwargs. Returns ------- None. \"\"\" X_pos , Y_pos = cell_XY_positions () # set size of markers diameter = 21.44 / 1000 ; area = np . pi * ( diameter / 2 ) ** 2 ; s = area * 4 / np . pi # points s = s * 72 / 0.0254 * 1000 # some scaling... # scatter plot sc = ax . scatter ( X_pos , Y_pos , s , c , ** kwargs ) # set limits ax . set_xlim ( - 0.1 , 0.1 ) ax . set_ylim ( - 0.06 , 0.06 ) # colorbar plt . colorbar ( sc , ax = ax , orientation = 'vertical' ) # set axis equal ax . set_aspect ( 'equal' ) ax . set_axis_off () vmin , vmax = sc . get_clim () if 'cmap' in kwargs : cmap = kwargs . get ( 'cmap' ) else : cmap = 'viridis' text_colors = text_color ( c , vmin , vmax , cmap ) # write cell text if val_text : cell_text ( ax , c , text_prec , text_colors ) if cellno_text : cell_text_numbers ( ax , text_colors ) if batch_col : cell_batch_color ( ax , s ) oversampling ( file_name , directory , N = 100 , derivative_limit = 10 , adaptive = True ) Give a file for the 2021 AMMBa battery testing a new file under an oversampling directory is created. End tag of _ad signifies adaptive oversampling was used. Parameters file_name : str File name (with extension) to oversample found in the specified directory. directory : str Directory where the specified file can be found. An oversampling folder will be created here. N : int, optional Number of points to average together. The default is 100. derivative_limit : float, optional Limit at which oversampling is conducted. A current derivative over this value will result in all data within N/2 points to be kept. The default is 10. adaptive : bool, optional If adaptive sampling is used. Without all data will be over sampled and high derivative points may be missed. The default is True Returns None. Source code in liionpack\\batteryrig_utils.py def oversampling ( file_name : str , directory : str , N : int = 100 , derivative_limit : float = 10 , adaptive : bool = True ): \"\"\" Give a file for the 2021 AMMBa battery testing a new file under an oversampling directory is created. End tag of _ad signifies adaptive oversampling was used. Parameters ---------- file_name : str File name (with extension) to oversample found in the specified directory. directory : str Directory where the specified file can be found. An oversampling folder will be created here. N : int, optional Number of points to average together. The default is 100. derivative_limit : float, optional Limit at which oversampling is conducted. A current derivative over this value will result in all data within N/2 points to be kept. The default is 10. adaptive : bool, optional If adaptive sampling is used. Without all data will be over sampled and high derivative points may be missed. The default is True Returns ------- None. \"\"\" oversampled_folder = os . path . join ( directory , 'oversampled' ) if not os . path . isdir ( oversampled_folder ): os . mkdir ( oversampled_folder ) look_forward = int (( N - 1 ) / 2 ) look_back = look_forward + (( N + 1 ) % 2 ) df = pd . read_csv ( os . path . join ( directory , file_name ), skiprows = [ 1 ]) n_points = len ( df ) if not adaptive : ii = 0 idx = list ( range ( ii , look_forward + 1 )) df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_temp [ 'Time' ] = df [ 'Time' ] . iloc [ ii ] df_new = pd . DataFrame ( data = df_temp , columns = df . columns ) ii += N done = False while not done : if ii + look_forward > n_points - 1 : ee = n_points - 1 done = True else : ee = ii + look_forward idx = list ( range ( ii - look_back , ee + 1 )) df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_temp [ 'Time' ] = df [ 'Time' ] . iloc [ ii ] df_new = df_new . append ( df_temp , ignore_index = True ) ii += N if ii >= n_points : done = True else : time = np . array ( df [ 'Time' ]) dT = np . append ( time [ 1 :] - time [: - 1 ], 1 ) current = sum ( np . transpose ( np . array ( df . iloc [:, 52 : 68 ]))) dI = np . append ( current [ 1 :] - current [: - 1 ], 0 ) df = df [ dT != 0 ] dI = dI [ dT != 0 ] dT = dT [ dT != 0 ] derivative = abs ( dI / dT ) n_points = len ( dI ) save_points = np . full ( n_points , False , dtype = bool ) for i in range ( n_points ): if derivative [ i ] > derivative_limit : if i - look_back < 0 : bb = 0 else : bb = i - look_back if i + look_forward > n_points - 1 : ff = n_points - 1 else : ff = i + look_forward idx = list ( range ( bb , ff )) save_points [ idx ] = True df_new = pd . DataFrame ( data = df . iloc [ 0 ], columns = df . columns ) idx = [] for i in range ( 1 , n_points - 1 ): if save_points [ i ]: idx = [ i ] else : if len ( idx ) == 0 : idx = [ i ] else : idx . append ( i ) if ( len ( idx ) == N ) or ( save_points [ i + 1 ] or ( save_points [ i ])): df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_new = df_new . append ( df_temp , ignore_index = True ) idx = [] df_new [ 'Time' ] = df_new [ 'Time' ] - df_new [ 'Time' ][ 0 ] output_file = os . path . join ( oversampled_folder , file_name ) df_new . to_csv ( output_file , sep = ',' , index = False , float_format = ' %.6g ' ) return load_data Created on Thu Sep 23 10:29:24 2021 @author: Tom load_simulation_data ( data_dir , filename = 'A25022021_2_D' ) A bespoke utility function to load in experimental data Parameters data_dir : str The parent directory for the data file. filename : str, optional The filename for the data. The default is 'A25022021_2_D'. Returns df : pandas.Dataframe An experimental data file Source code in liionpack\\load_data.py def load_simulation_data ( data_dir , filename = 'A25022021_2_D' ): r ''' A bespoke utility function to load in experimental data Parameters ---------- data_dir : str The parent directory for the data file. filename : str, optional The filename for the data. The default is 'A25022021_2_D'. Returns ------- df : pandas.Dataframe An experimental data file ''' df = pd . read_csv ( os . path . join ( data_dir , filename + '.txt' )) # calculate zero currents df = batteryrig_utils . zero_currents ( df ) df = batteryrig_utils . calc_cell_voltages ( df ) st = 172 tmap = df [ 'Time' ] > st df = df [ tmap ] tlow = df [ 'Time' ] . min () df [ 'Time' ] -= tlow df . set_index ( 'Time' , inplace = True , drop = False ) return df netlist_utils Created on Thu Sep 23 10:36:15 2021 @author: Tom read_netlist ( filepath , Ri = 0.01 , Rc = 0.01 , Rb = 0.0001 , Rl = 0.0005 , I = 80.0 , V = 4.2 ) Assumes netlist has been saved by LTSpice with format Descriptor Node1 Node2 Value Any lines starting with * are comments and . are commands so ignore them Nodes begin with N so remove that Open ended components are not allowed and their nodes start with NC (no-connection) Parameters filepath : str path to netlist circuit file '.cir'. Ri : float Internal resistance (:math: \\Omega ). The default is 1e-2. Rc : float Connection resistance (:math: \\Omega ). The default is 1e-2. Rb : float Busbar resistance (:math: \\Omega ). The default is 1e-4. Rl : float Long Busbar resistance (:math: \\Omega ). The default is 5e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. Returns netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Source code in liionpack\\netlist_utils.py def read_netlist ( filepath , Ri = 1e-2 , Rc = 1e-2 , Rb = 1e-4 , Rl = 5e-4 , I = 80.0 , V = 4.2 ): r ''' Assumes netlist has been saved by LTSpice with format Descriptor Node1 Node2 Value Any lines starting with * are comments and . are commands so ignore them Nodes begin with N so remove that Open ended components are not allowed and their nodes start with NC (no-connection) Parameters ---------- filepath : str path to netlist circuit file '.cir'. Ri : float Internal resistance (:math:`\\Omega`). The default is 1e-2. Rc : float Connection resistance (:math:`\\Omega`). The default is 1e-2. Rb : float Busbar resistance (:math:`\\Omega`). The default is 1e-4. Rl : float Long Busbar resistance (:math:`\\Omega`). The default is 5e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. Returns ------- netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. ''' if '.cir' not in filepath : filepath += '.cir' if not os . path . isfile ( filepath ): temp = os . path . join ( lp . CIRCUIT_DIR , filepath ) if not os . path . isfile ( temp ): pass else : filepath = temp with codecs . open ( filepath , \"r\" , \"utf-16LE\" ) as fd : Lines = fd . readlines () Lines = [ l . strip ( ' \\n ' ) . split ( ' ' ) for l in Lines if l [ 0 ] not in [ '*' , '.' ]] Lines = np . array ( Lines , dtype = '<U16' ) desc = Lines [:, 0 ] N1 = Lines [:, 1 ] N2 = Lines [:, 2 ] # values = Lines[:, 3] values = np . zeros ( len ( N1 )) N1 = np . array ([ x . strip ( 'N' ) for x in N1 ], dtype = int ) N2 = np . array ([ x . strip ( 'N' ) for x in N2 ], dtype = int ) netlist = pd . DataFrame ({ 'desc' : desc , 'node1' : N1 , 'node2' : N2 , 'value' : values }) Ri_map = netlist [ 'desc' ] . str . find ( 'Ri' ) > - 1 Rc_map = netlist [ 'desc' ] . str . find ( 'Rc' ) > - 1 Rb_map = netlist [ 'desc' ] . str . find ( 'Rb' ) > - 1 Rl_map = netlist [ 'desc' ] . str . find ( 'Rl' ) > - 1 V_map = netlist [ 'desc' ] . str . find ( 'V' ) > - 1 I_map = netlist [ 'desc' ] . str . find ( 'I' ) > - 1 netlist . loc [ Ri_map , ( 'value' )] = Ri netlist . loc [ Rc_map , ( 'value' )] = Rc netlist . loc [ Rb_map , ( 'value' )] = Rb netlist . loc [ Rl_map , ( 'value' )] = Rl netlist . loc [ I_map , ( 'value' )] = I netlist . loc [ V_map , ( 'value' )] = V return netlist setup_circuit ( Np , Ns , Ri = 0.01 , Rc = 0.01 , Rb = 0.0001 , Rl = 0.0005 , I = 80.0 , V = 4.2 , plot = False ) Define a netlist from a number of batteries in parallel and series Parameters Np : int Number of batteries in parallel. Ns : int Number of batteries in series. Ri : float Internal resistance (:math: \\Omega ). The default is 1e-2. Rc : float Connection resistance (:math: \\Omega ). The default is 1e-2. Rb : float Busbar resistance (:math: \\Omega ). The default is 1e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. plot : bool, optional Plot the circuit. The default is False. Returns netlist : TYPE DESCRIPTION. Source code in liionpack\\netlist_utils.py def setup_circuit ( Np , Ns , Ri = 1e-2 , Rc = 1e-2 , Rb = 1e-4 , Rl = 5e-4 , I = 80.0 , V = 4.2 , plot = False ): r ''' Define a netlist from a number of batteries in parallel and series Parameters ---------- Np : int Number of batteries in parallel. Ns : int Number of batteries in series. Ri : float Internal resistance (:math:`\\Omega`). The default is 1e-2. Rc : float Connection resistance (:math:`\\Omega`). The default is 1e-2. Rb : float Busbar resistance (:math:`\\Omega`). The default is 1e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. plot : bool, optional Plot the circuit. The default is False. Returns ------- netlist : TYPE DESCRIPTION. ''' tic = ticker . time () Nc = Np + 1 Nr = Ns * 3 + 1 grid = np . arange ( Nc * Nr ) . reshape ([ Nr , Nc ]) # 1st column is terminals only # 1st and last rows are busbars # Other rows alternate between series resistor and voltage source # Build data with ['element type', Node1, Node2, value] netlist = [] num_Rb = 0 num_I = 0 num_V = 0 desc = [] node1 = [] node2 = [] value = [] # Current source - same end # netline = [] # terminal_nodes = [, ] desc . append ( 'I' + str ( num_I )) num_I += 1 node1 . append ( grid [ 0 , 0 ]) node2 . append ( grid [ - 1 , 0 ]) value . append ( I ) # netlist.append(netline) # Infinite Resistor # netline = [] # terminal_nodes = [grid[0, -1], grid[-1, -1]] # netline.append('R_inf') # netline += terminal_nodes # netline.append(1e6) # netlist.append(netline) # +ve & -ve busbars bus_nodes = [ grid [ - 1 , :], grid [ 0 , :]] for nodes in bus_nodes : for i in range ( len ( nodes ) - 1 ): # netline = [] desc . append ( 'Rb' + str ( num_Rb )) num_Rb += 1 node1 . append ( nodes [ i ]) node2 . append ( nodes [ i + 1 ]) value . append ( Rb ) # netlist.append(netline) num_Rs = 0 num_Ri = 0 # Series resistors and voltage sources cols = np . arange ( Nc )[ 1 :] rows = np . arange ( Nr )[: - 1 ] rtype = [ 'Rs' , 'V' , 'Ri' ] * Ns for col in cols : nodes = grid [:, col ] for row in rows : # netline = [] if rtype [ row ][ 0 ] == 'R' : if rtype [ row ][ 1 ] == 's' : # Series resistor desc . append ( rtype [ row ] + str ( num_Rs )) num_Rs += 1 val = Rc else : # Internal resistor desc . append ( rtype [ row ] + str ( num_Ri )) num_Ri += 1 val = Ri node1 . append ( nodes [ row ]) node2 . append ( nodes [ row + 1 ]) else : # Voltage source desc . append ( 'V' + str ( num_V )) num_V += 1 val = V node1 . append ( nodes [ row + 1 ]) node2 . append ( nodes [ row ]) value . append ( val ) # netlist.append(netline) coords = np . indices ( grid . shape ) y = coords [ 0 , :, :] . flatten () x = coords [ 1 , :, :] . flatten () if plot : plt . figure () # plt.scatter(x, y, c='k') for netline in zip ( desc , node1 , node2 ): elem , n1 , n2 , = netline if elem [ 0 ] == 'I' : color = 'g' elif elem [ 0 ] == 'R' : if elem [ 1 ] == 's' : color = 'r' elif elem [ 1 ] == 'b' : color = 'k' else : color = 'y' elif elem [ 0 ] == 'V' : color = 'b' x1 = x [ n1 ] x2 = x [ n2 ] y1 = y [ n1 ] y2 = y [ n2 ] # print(n1, n2) plt . scatter ([ x1 , x2 ], [ y1 , y2 ], c = 'k' ) plt . plot ([ x1 , x2 ], [ y1 , y2 ], c = color ) desc = np . asarray ( desc ) node1 = np . asarray ( node1 ) node2 = np . asarray ( node2 ) value = np . asarray ( value ) # netlist = np.asarray(netlist, dtype='<U16') node1 , node2 = _make_contiguous ( node1 , node2 ) netlist = pd . DataFrame ({ 'desc' : desc , 'node1' : node1 , 'node2' : node2 , 'value' : value }) toc = ticker . time () print ( 'Setup circuit time' , np . around ( toc - tic , 3 )) return netlist solve_circuit ( netlist ) Parameters netlist : TYPE DESCRIPTION. Returns None. Source code in liionpack\\netlist_utils.py def solve_circuit ( netlist ): r ''' Parameters ---------- netlist : TYPE DESCRIPTION. Returns ------- None. ''' tic = ticker . time () # Name = netlist[:, 0] # element names # N1 = netlist[:, 1].astype(int) # Node numbers # N2 = netlist[:, 2].astype(int) # arg3 = netlist[:, 3].astype(float) # Values Name = np . array ( netlist [ 'desc' ]) . astype ( '<U16' ) N1 = np . array ( netlist [ 'node1' ]) N2 = np . array ( netlist [ 'node2' ]) arg3 = np . array ( netlist [ 'value' ]) n = np . concatenate (( N1 , N2 )) . max () # Highest node number nLines = netlist . shape [ 0 ] m = 0 # \"m\" is the number of voltage sources, determined below. V_elem = [ 'V' , 'O' , 'E' , 'H' ] for nm in Name : if nm [ 0 ] in V_elem : m += 1 G = np . zeros ([ n , n ]) B = np . zeros ([ n , m ]) D = np . zeros ([ m , m ]) i = np . zeros ([ n , 1 ]) e = np . zeros ([ m , 1 ]) \"\"\" % We need to keep track of the number of voltage sources we've parsed % so far as we go through file. We start with zero. \"\"\" vsCnt = 0 \"\"\" % This loop does the bulk of filling in the arrays. It scans line by line % and fills in the arrays depending on the type of element found on the % current line. % See http://lpsa.swarthmore.edu/Systems/Electrical/mna/MNA3.html \"\"\" for k1 in range ( nLines ): n1 = N1 [ k1 ] - 1 # get the two node numbers in python index format n2 = N2 [ k1 ] - 1 elem = Name [ k1 ][ 0 ] if elem == 'R' : g = 1 / arg3 [ k1 ] # conductance = 1 / R \"\"\" % Here we fill in G array by adding conductance. % The procedure is slightly different if one of the nodes is % ground, so check for those accordingly. \"\"\" if n1 == - 1 : # -1 is the ground node G [ n2 , n2 ] = G [ n2 , n2 ] + g elif n2 == - 1 : G [ n1 , n1 ] = G [ n1 , n1 ] + g else : G [ n1 , n1 ] = G [ n1 , n1 ] + g G [ n2 , n2 ] = G [ n2 , n2 ] + g G [ n1 , n2 ] = G [ n1 , n2 ] - g G [ n2 , n1 ] = G [ n2 , n1 ] - g elif elem == 'V' : if n1 >= 0 : B [ n1 , vsCnt ] = B [ n1 , vsCnt ] + 1 if n2 >= 0 : B [ n2 , vsCnt ] = B [ n2 , vsCnt ] - 1 e [ vsCnt ] = arg3 [ k1 ] vsCnt += 1 elif elem == 'I' : if n1 >= 0 : i [ n1 ] = i [ n1 ] - arg3 [ k1 ] if n2 >= 0 : i [ n2 ] = i [ n2 ] + arg3 [ k1 ] upper = np . hstack (( G , B )) lower = np . hstack (( B . T , D )) A = np . vstack (( upper , lower )) z = np . vstack (( i , e )) X = solve ( A , z ) . flatten () # include ground node V_node = np . zeros ( n + 1 ) V_node [ 1 :] = X [: n ] I_batt = X [ n :] # print(X) toc = ticker . time () print ( 'Solve circuit time' , np . around ( toc - tic , 3 )) return V_node , I_batt protocols Created on Thu Sep 23 14:44:19 2021 @author: Tom generate_protocol ( I_dch =- 50 , I_chg = 50 , t_dch = 180 , t_chg = 180 , t_rest = 90 , chg_first = True ) Parameters I_dch : float Negative discharge current [A]. The default is -50. I_chg : float Positive charge current [A]. The default is 50. t_dch : int number of time steps to discharge. The default is 180. t_chg : int number of time steps to charge. The default is 180. t_rest : int, optional number of time steps to rest inbetween charge and discharge. The default is 90. chg_first : bool charge before discharge. The default is True Returns proto : list a sequence of terminal currents to apply at each timestep Source code in liionpack\\protocols.py def generate_protocol ( I_dch =- 50 , I_chg = 50 , t_dch = 180 , t_chg = 180 , t_rest = 90 , chg_first = True ): r ''' Parameters ---------- I_dch : float Negative discharge current [A]. The default is -50. I_chg : float Positive charge current [A]. The default is 50. t_dch : int number of time steps to discharge. The default is 180. t_chg : int number of time steps to charge. The default is 180. t_rest : int, optional number of time steps to rest inbetween charge and discharge. The default is 90. chg_first : bool charge before discharge. The default is True Returns ------- proto : list a sequence of terminal currents to apply at each timestep ''' if chg_first : proto = [ I_chg ] * t_chg + [ 0.0 ] * t_rest + [ I_dch ] * t_dch + [ 0.0 ] * t_rest else : proto = [ I_dch ] * t_dch + [ 0.0 ] * t_rest + [ I_chg ] * t_chg + [ 0.0 ] * t_rest return proto test_protocol () retun a simple test protocol with no options Returns proto : list a test sequence of terminal currents to apply at each timestep. Source code in liionpack\\protocols.py def test_protocol (): r ''' retun a simple test protocol with no options Returns ------- proto : list a test sequence of terminal currents to apply at each timestep. ''' return generate_protocol ( I_dch =- 50 , I_chg = 50 , t_dch = 30 , t_chg = 30 , t_rest = 15 ) sim_utils Created on Thu Sep 23 10:41:16 2021 @author: Tom create_init_funcs ( parameter_values = None ) Parameters parameter_values : TYPE, optional DESCRIPTION. The default is None. Returns None. Source code in liionpack\\sim_utils.py def create_init_funcs ( parameter_values = None ): r ''' Parameters ---------- parameter_values : TYPE, optional DESCRIPTION. The default is None. Returns ------- None. ''' V_upper_limit = parameter_values [ 'Upper voltage cut-off [V]' ] V_lower_limit = parameter_values [ 'Lower voltage cut-off [V]' ] # Make sure we slow charge to upper limit and establish equilibrium experiment = pybamm . Experiment ( [ f \"Charge at C/50 until { V_upper_limit } V (10 second period)\" , f \"Hold at { V_upper_limit } V until 0.5mA (10 second period)\" , \"Rest for 30 minutes (1 minute period)\" , f \"Discharge at C/100 until { V_lower_limit } V (1 minute period)\" , ] ) # sim.set_up_experiment(model, experiment) # sim = pybamm.Simulation(model=model, parameter_values=param, experiment=experiment) sim = lp . create_simulation ( parameter_values = parameter_values , experiment = experiment ) sim . solve () # sim.plot() # param = sim.parameter_values # Save concentrations for initial conditions neg_surf = 'X-averaged negative particle surface concentration [mol.m-3]' pos_surf = 'X-averaged positive particle surface concentration [mol.m-3]' sol_charged = sim . solution . cycles [ 2 ] v_upper_lim_neg = sol_charged [ neg_surf ] . entries [ - 1 ] v_upper_lim_pos = sol_charged [ pos_surf ] . entries [ - 1 ] # Save lower concentrations sol_dischg = sim . solution . cycles [ 3 ] v_lower_lim_neg = sol_dischg [ neg_surf ] . entries [ - 1 ] v_lower_lim_pos = sol_dischg [ pos_surf ] . entries [ - 1 ] # Use max conc. for normalization c_s_n_max = parameter_values [ 'Maximum concentration in negative electrode [mol.m-3]' ] c_s_p_max = parameter_values [ 'Maximum concentration in positive electrode [mol.m-3]' ] # These are now the min and max concs for full range of SoC x_n_max = v_upper_lim_neg / c_s_n_max x_p_min = v_upper_lim_pos / c_s_p_max x_n_min = v_lower_lim_neg / c_s_n_max x_p_max = v_lower_lim_pos / c_s_p_max # Work out total capacity between voltage lims current = sol_dischg [ 'Current [A]' ] . entries time = sol_dischg [ 'Time [h]' ] . entries dt = time [ 1 :] - time [: - 1 ] c_ave = ( current [ 1 :] + current [: - 1 ]) / 2 charge = np . cumsum ( c_ave * dt ) plt . figure () plt . plot ( time [ 1 :], charge ) plt . xlabel ( 'Time [h]' ) plt . ylabel ( 'Cumulative Charge Transferred [Ah]' ) SoC = np . linspace ( 0 , 1 , 1000 ) x_n = x_n_min + ( x_n_max - x_n_min ) * SoC x_p = x_p_max - ( x_p_max - x_p_min ) * SoC try : # Ocp are functions U_n = parameter_values [ 'Negative electrode OCP [V]' ] U_p = parameter_values [ 'Positive electrode OCP [V]' ] U_n_eval = parameter_values . evaluate ( U_n ( pybamm . Array ( x_n ))) U_p_eval = parameter_values . evaluate ( U_p ( pybamm . Array ( x_p ))) OCV = U_p_eval - U_n_eval OCV = OCV . flatten () except : # Ocp is data # Get the OCP data and plot it from the parameters neg_ocp = parameter_values [ 'Negative electrode OCP [V]' ][ 1 ] pos_ocp = parameter_values [ 'Positive electrode OCP [V]' ][ 1 ] # Split the data neg_x = neg_ocp [:, 0 ] neg_y = neg_ocp [:, 1 ] pos_x = pos_ocp [:, 0 ] pos_y = pos_ocp [:, 1 ] # plt.figure() # plt.plot(neg_x, neg_y) # plt.title('Neg OCP') # plt.ylabel('OCP [V]') # plt.xlabel('Lithiation') # plt.figure() # plt.plot(pos_x, pos_y) # plt.title('Pos OCP') # plt.ylabel('OCP [V]') # plt.xlabel('Lithiation') # interpolant functions U_n = interp1d ( neg_x , neg_y ) U_p = interp1d ( pos_x , pos_y ) # OCV theoretical based on discharge at eqm OCV = U_p ( x_p ) - U_n ( x_n ) # Compare to C/100 plt . figure () plt . plot ( SoC , OCV ) plt . ylabel ( 'OCP [V]' ) plt . xlabel ( 'SoC' ) terminal = sol_dischg [ 'Terminal voltage [V]' ] . entries plt . plot ( np . linspace ( 0.0 , 1.0 , len ( terminal ))[:: - 1 ], terminal , 'r--' ) # Reverse interpolants to get back lithiation states from SoC and OCV x_n_SoC = interp1d ( SoC , x_n ) x_p_SoC = interp1d ( SoC , x_p ) x_n_OCV = interp1d ( OCV , x_n ) x_p_OCV = interp1d ( OCV , x_p ) vmin = float ( V_lower_limit ) vmax = float ( V_upper_limit ) init_funcs = { 'x_n_SoC' : x_n_SoC , 'x_p_SoC' : x_p_SoC , 'x_n_OCV' : x_n_OCV , 'x_p_OCV' : x_p_OCV , 'c_s_n_max' : c_s_n_max , 'c_s_p_max' : c_s_p_max , 'vmin' : vmin , 'vmax' : vmax } with open ( init_fname , 'wb' ) as handle : pickle . dump ( init_funcs , handle ) initial_conditions ( SoC =- 1 , OCV =- 1 ) Parameters SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns c_s_n_init : TYPE DESCRIPTION. c_s_p_init : TYPE DESCRIPTION. Source code in liionpack\\sim_utils.py def initial_conditions ( SoC =- 1 , OCV =- 1 ): r ''' Parameters ---------- SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns ------- c_s_n_init : TYPE DESCRIPTION. c_s_p_init : TYPE DESCRIPTION. ''' with open ( init_fname , 'rb' ) as handle : init_funcs = pickle . load ( handle ) x_n_SoC = init_funcs [ 'x_n_SoC' ] x_p_SoC = init_funcs [ 'x_p_SoC' ] x_n_OCV = init_funcs [ 'x_n_OCV' ] x_p_OCV = init_funcs [ 'x_p_OCV' ] c_s_n_max = init_funcs [ 'c_s_n_max' ] c_s_p_max = init_funcs [ 'c_s_p_max' ] vmin = init_funcs [ 'vmin' ] vmax = init_funcs [ 'vmax' ] if SoC >= 0.0 and SoC <= 1.0 : x_n_init = x_n_SoC ( SoC ) x_p_init = x_p_SoC ( SoC ) elif OCV >= vmin and OCV <= vmax : x_n_init = x_n_OCV ( OCV ) x_p_init = x_p_OCV ( OCV ) c_s_n_init = x_n_init * c_s_n_max c_s_p_init = x_p_init * c_s_p_max return c_s_n_init , c_s_p_init update_init_conc ( sim , SoC =- 1 , OCV =- 1 ) Parameters sim : TYPE DESCRIPTION. SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns None. Source code in liionpack\\sim_utils.py def update_init_conc ( sim , SoC =- 1 , OCV =- 1 ): r ''' Parameters ---------- sim : TYPE DESCRIPTION. SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns ------- None. ''' param = sim . parameter_values c_s_n_init , c_s_p_init = initial_conditions ( SoC = SoC , OCV = OCV ) param . update ({ \"Initial concentration in negative electrode [mol.m-3]\" : c_s_n_init , \"Initial concentration in positive electrode [mol.m-3]\" : c_s_p_init , }) simulations Created on Wed Sep 22 15:37:51 2021 @author: tom create_simulation ( parameter_values = None , experiment = None , make_inputs = False ) Create a PyBaMM simulation set up for interation with liionpack Parameters parameter_values : pybamm.ParameterValues class DESCRIPTION. The default is None. experiment : pybamm.Experiment class DESCRIPTION. The default is None. make_inputs : bool, optional Changes \"Current function [A]\" and \"Total heat transfer coefficient [W.m-2.K-1]\" to be inputs that are controlled by liionpack. The default is False. Returns sim : pybamm.Simulation A simulation that can be solved individually or passed into the liionpack solve method Source code in liionpack\\simulations.py def create_simulation ( parameter_values = None , experiment = None , make_inputs = False ): r ''' Create a PyBaMM simulation set up for interation with liionpack Parameters ---------- parameter_values : pybamm.ParameterValues class DESCRIPTION. The default is None. experiment : pybamm.Experiment class DESCRIPTION. The default is None. make_inputs : bool, optional Changes \"Current function [A]\" and \"Total heat transfer coefficient [W.m-2.K-1]\" to be inputs that are controlled by liionpack. The default is False. Returns ------- sim : pybamm.Simulation A simulation that can be solved individually or passed into the liionpack solve method ''' # Create the pybamm model model = pybamm . lithium_ion . SPMe ( options = { \"thermal\" : \"lumped\" , # \"external submodels\": [\"thermal\"], }) # geometry = model.default_geometry if parameter_values is None : # load parameter values and process model and geometry chemistry = pybamm . parameter_sets . Chen2020 param = pybamm . ParameterValues ( chemistry = chemistry ) # Change the current function to be an input as this is set by the external circuit if make_inputs : parameter_values . update ({ \"Current function [A]\" : _current_function ,}) parameter_values . update ({ \"Current\" : \"[input]\" , \"Total heat transfer coefficient [W.m-2.K-1]\" : \"[input]\" }, check_already_exists = False ) solver = pybamm . CasadiSolver ( mode = 'safe' ) sim = pybamm . Simulation ( model = model , experiment = experiment , parameter_values = parameter_values , solver = solver ) return sim solver_utils Created on Thu Sep 23 10:44:31 2021 @author: Tom solve ( netlist = None , parameter_values = None , protocol = None , dt = 10 , I_init = 1.0 , htc = None , nproc = 12 , output_variables = None ) Solves a pack simulation Parameters netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Produced by liionpack.read_netlist or liionpack.setup_circuit parameter_values : pybamm.ParameterValues class A dictionary of all the model parameters proto : list a sequence of terminal currents to apply at each timestep. Produced by liionpack.generate_protocol dt : float, optional Time interval for a single step [s]. The default is 10. I_init : float, optional Initial guess for single battery current [A]. The default is 1.0. htc : float array, optional Heat transfer coefficient array of length Nspm. The default is None. nproc : int, optional Number of processes to start in parallel for mapping. The default is 12. output_variables : list, optional Variables to evaluate during solve. Must be a valid key in the model.variables Raises Exception DESCRIPTION. Returns output : ndarray shape [# variable, # steps, # batteries] simulation output array Source code in liionpack\\solver_utils.py def solve ( netlist = None , parameter_values = None , protocol = None , dt = 10 , I_init = 1.0 , htc = None , nproc = 12 , output_variables = None ): r ''' Solves a pack simulation Parameters ---------- netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Produced by liionpack.read_netlist or liionpack.setup_circuit parameter_values : pybamm.ParameterValues class A dictionary of all the model parameters proto : list a sequence of terminal currents to apply at each timestep. Produced by liionpack.generate_protocol dt : float, optional Time interval for a single step [s]. The default is 10. I_init : float, optional Initial guess for single battery current [A]. The default is 1.0. htc : float array, optional Heat transfer coefficient array of length Nspm. The default is None. nproc : int, optional Number of processes to start in parallel for mapping. The default is 12. output_variables : list, optional Variables to evaluate during solve. Must be a valid key in the model.variables Raises ------ Exception DESCRIPTION. Returns ------- output : ndarray shape [# variable, # steps, # batteries] simulation output array ''' if netlist is None or parameter_values is None or protocol is None : raise Exception ( 'Please supply a netlist, paramater_values and protocol' ) # Get netlist indices for resistors, voltage sources, current sources Ri_map = netlist [ 'desc' ] . str . find ( 'Ri' ) > - 1 V_map = netlist [ 'desc' ] . str . find ( 'V' ) > - 1 I_map = netlist [ 'desc' ] . str . find ( 'I' ) > - 1 Nspm = np . sum ( V_map ) Nsteps = len ( protocol ) # Solve the circuit to initialise the electrochemical models V_node , I_batt = lp . solve_circuit ( netlist ) sim = lp . create_simulation ( parameter_values , make_inputs = True ) lp . update_init_conc ( sim , SoC = 0.14 ) v_cut_lower = parameter_values [ 'Lower voltage cut-off [V]' ] v_cut_higher = parameter_values [ 'Upper voltage cut-off [V]' ] # The simulation output variables calculated at each step for each battery # Must be a 0D variable i.e. battery wide volume average - or X-averaged for 1D model variable_names = [ 'Terminal voltage [V]' , 'Measured battery open circuit voltage [V]' , 'Local ECM resistance [Ohm]' ] if output_variables is not None : for out in output_variables : if out not in variable_names : variable_names . append ( out ) # variable_names = variable_names + output_variables Nvar = len ( variable_names ) # Storage variables for simulation data shm_i_app = np . zeros ([ Nsteps , Nspm ], dtype = float ) shm_Ri = np . zeros ([ Nsteps , Nspm ], dtype = float ) output = np . zeros ([ Nvar , Nsteps , Nspm ], dtype = float ) # Initialize currents in battery models shm_i_app [ 0 , :] = I_batt * - 1 time = 0 step = 0 end_time = dt * Nsteps step_solutions = [ None ] * Nspm V_terminal = [] record_times = [] integrator , variables_fn , t_eval = _create_casadi_objects ( I_init , htc [ 0 ], sim , dt , Nspm , nproc , variable_names ) sim_start_time = ticker . time () while time < end_time : print ( step , 'Time' , time ) tic = ticker . time () step_solutions , var_eval = _mapped_step ( sim . built_model , step_solutions , lp . build_inputs_dict ( shm_i_app [ step , :], htc ), integrator , variables_fn , t_eval ) output [:, step , :] = var_eval time += dt # Calculate internal resistance and update netlist temp_v = output [ 0 , step , :] temp_ocv = output [ 1 , step , :] temp_Ri = np . abs ( output [ 2 , step , :]) shm_Ri [ step , :] = temp_Ri netlist . loc [ V_map , ( 'value' )] = temp_ocv netlist . loc [ Ri_map , ( 'value' )] = temp_Ri netlist . loc [ I_map , ( 'value' )] = protocol [ step ] print ( 'Stepping time' , np . around ( ticker . time () - tic , 2 ), 's' ) if np . any ( temp_v < v_cut_lower ): print ( 'Low V limit reached' ) break if np . any ( temp_v > v_cut_higher ): print ( 'High V limit reached' ) break step += 1 if time < end_time : record_times . append ( time ) V_node , I_batt = lp . solve_circuit ( netlist ) shm_i_app [ step , :] = I_batt [:] * - 1 V_terminal . append ( V_node . max ()) # Plots colors = plt . cm . jet ( np . linspace ( 0 , 1 , Nspm )) plt . figure () for i in range ( Nspm ): plt . plot ( shm_i_app [ 1 : step , i ], color = colors [ i ]) plt . title ( 'Currents' ) for j in range ( Nvar ): plt . figure () for i in range ( Nspm ): plt . plot ( output [ j , 1 : step , i ], color = colors [ i ]) plt . title ( variable_names [ j ]) plt . figure () plt . plot ( record_times , V_terminal , label = 'simulation' ) plt . title ( 'Pack terminal voltage [V]' ) plt . legend () toc = ticker . time () print ( 'Solve circuit time' , np . around ( toc - sim_start_time , 3 )) return output utils Created on Thu Sep 23 10:33:13 2021 @author: Tom build_inputs_dict ( I_batt , htc ) Function to convert inputs and external_variable arrays to list of dicts As expected by the casadi solver. These are then converted back for mapped solving but stored individually on each returned solution. Can probably remove this process later Parameters I_batt : float array The input current for each battery. htc : float array the heat transfer coefficient for each battery. Returns inputs_dict : list each element of the list is an inputs dictionary corresponding to each battery. Source code in liionpack\\utils.py def build_inputs_dict ( I_batt , htc ): r ''' Function to convert inputs and external_variable arrays to list of dicts As expected by the casadi solver. These are then converted back for mapped solving but stored individually on each returned solution. Can probably remove this process later Parameters ---------- I_batt : float array The input current for each battery. htc : float array the heat transfer coefficient for each battery. Returns ------- inputs_dict : list each element of the list is an inputs dictionary corresponding to each battery. ''' inputs_dict = [] for i in range ( len ( I_batt )): inputs_dict . append ({ # 'Volume-averaged cell temperature': T_batt[i], \"Current\" : I_batt [ i ], \"Total heat transfer coefficient [W.m-2.K-1]\" : htc [ i ], }) return inputs_dict get_interpolated_htc ( funcs , T , Q ) A very bespoke function that is called in the solve process to update the heat transfer coefficients for every battery Parameters funcs : list each element of the list is an interpolant function. T : float array The temperature of each battery. Q : float The flow rate for the system. Returns htc : float Heat transfer coefficient for each battery. Source code in liionpack\\utils.py def get_interpolated_htc ( funcs , T , Q ): r ''' A very bespoke function that is called in the solve process to update the heat transfer coefficients for every battery Parameters ---------- funcs : list each element of the list is an interpolant function. T : float array The temperature of each battery. Q : float The flow rate for the system. Returns ------- htc : float Heat transfer coefficient for each battery. ''' ncell = len ( T ) htc = np . zeros ( ncell ) for i in range ( ncell ): htc [ i ] = funcs [ i ]( T [ i ], Q ) return htc interp_current ( df ) Returns an interpolation function for current w.r.t time Parameters df : pandas.DataFrame or Dict Contains data for 'Time' and 'Cells Total Current' from which to construct an interpolant function Returns f : function interpolant function of total cell current with time. Source code in liionpack\\utils.py def interp_current ( df ): r ''' Returns an interpolation function for current w.r.t time Parameters ---------- df : pandas.DataFrame or Dict Contains data for 'Time' and 'Cells Total Current' from which to construct an interpolant function Returns ------- f : function interpolant function of total cell current with time. ''' t = df [ 'Time' ] I = df [ 'Cells Total Current' ] f = interp1d ( t , I ) return f read_cfd_data ( data_dir = None , filename = 'cfd_data.xlsx' ) A very bespoke function to read heat transfer coefficients from an excel file Parameters data_dir : str, optional Path to data file. The default is None. If unspecified the module liionpack.DATA_DIR folder will be used filename : str, optional DESCRIPTION. The default is 'cfd_data.xlsx'. Returns funcs : list an interpolant is returned for each cell in the excel file. Source code in liionpack\\utils.py def read_cfd_data ( data_dir = None , filename = 'cfd_data.xlsx' ): r ''' A very bespoke function to read heat transfer coefficients from an excel file Parameters ---------- data_dir : str, optional Path to data file. The default is None. If unspecified the module liionpack.DATA_DIR folder will be used filename : str, optional DESCRIPTION. The default is 'cfd_data.xlsx'. Returns ------- funcs : list an interpolant is returned for each cell in the excel file. ''' if data_dir is None : data_dir = liionpack . DATA_DIR fpath = os . path . join ( data_dir , filename ) ncells = 32 flow_bps = np . array ( pd . read_excel ( fpath , sheet_name = 'massflow_bps' , header = None )) temp_bps = np . array ( pd . read_excel ( fpath , sheet_name = 'temperature_bps' , header = None )) xv , yv = np . meshgrid ( temp_bps , flow_bps ) data = np . zeros ([ len ( temp_bps ), len ( flow_bps ), ncells ]) funcs = [] for i in range ( ncells ): data [:, :, i ] = np . array ( pd . read_excel ( fpath , sheet_name = 'cell' + str ( i + 1 ), header = None )) funcs . append ( interp2d ( xv , yv , data [:, :, i ], kind = 'linear' )) return funcs","title":"Reference"},{"location":"reference/#liionpack.batteryrig_utils","text":"Created on Tue Feb 23 14:57:53 2021 @author: dominicdathan","title":"batteryrig_utils"},{"location":"reference/#liionpack.batteryrig_utils.cell_scatter_plot","text":"","title":"cell_scatter_plot()"},{"location":"reference/#liionpack.batteryrig_utils.cell_scatter_plot--parameters","text":"ax : matplotlib axis obj axis to plot on. c : like plt.scatter c kwarg colors to plot scatter with. val_text : bool write values on plot cellno_text : bool write cell numbers on plot batch_col : color cells by batch text_prec : int precsition to write text of values on cells. **kwargs : plt.scatter kwargs.","title":"Parameters"},{"location":"reference/#liionpack.batteryrig_utils.cell_scatter_plot--returns","text":"None. Source code in liionpack\\batteryrig_utils.py def cell_scatter_plot ( ax , c , val_text = False , cellno_text = False , batch_col = False , text_prec = 1 , ** kwargs ): \"\"\" Parameters ---------- ax : matplotlib axis obj axis to plot on. c : like plt.scatter c kwarg colors to plot scatter with. val_text : bool write values on plot cellno_text : bool write cell numbers on plot batch_col : color cells by batch text_prec : int precsition to write text of values on cells. **kwargs : plt.scatter kwargs. Returns ------- None. \"\"\" X_pos , Y_pos = cell_XY_positions () # set size of markers diameter = 21.44 / 1000 ; area = np . pi * ( diameter / 2 ) ** 2 ; s = area * 4 / np . pi # points s = s * 72 / 0.0254 * 1000 # some scaling... # scatter plot sc = ax . scatter ( X_pos , Y_pos , s , c , ** kwargs ) # set limits ax . set_xlim ( - 0.1 , 0.1 ) ax . set_ylim ( - 0.06 , 0.06 ) # colorbar plt . colorbar ( sc , ax = ax , orientation = 'vertical' ) # set axis equal ax . set_aspect ( 'equal' ) ax . set_axis_off () vmin , vmax = sc . get_clim () if 'cmap' in kwargs : cmap = kwargs . get ( 'cmap' ) else : cmap = 'viridis' text_colors = text_color ( c , vmin , vmax , cmap ) # write cell text if val_text : cell_text ( ax , c , text_prec , text_colors ) if cellno_text : cell_text_numbers ( ax , text_colors ) if batch_col : cell_batch_color ( ax , s )","title":"Returns"},{"location":"reference/#liionpack.batteryrig_utils.oversampling","text":"Give a file for the 2021 AMMBa battery testing a new file under an oversampling directory is created. End tag of _ad signifies adaptive oversampling was used. Parameters file_name : str File name (with extension) to oversample found in the specified directory. directory : str Directory where the specified file can be found. An oversampling folder will be created here. N : int, optional Number of points to average together. The default is 100. derivative_limit : float, optional Limit at which oversampling is conducted. A current derivative over this value will result in all data within N/2 points to be kept. The default is 10. adaptive : bool, optional If adaptive sampling is used. Without all data will be over sampled and high derivative points may be missed. The default is True","title":"oversampling()"},{"location":"reference/#liionpack.batteryrig_utils.oversampling--returns","text":"None. Source code in liionpack\\batteryrig_utils.py def oversampling ( file_name : str , directory : str , N : int = 100 , derivative_limit : float = 10 , adaptive : bool = True ): \"\"\" Give a file for the 2021 AMMBa battery testing a new file under an oversampling directory is created. End tag of _ad signifies adaptive oversampling was used. Parameters ---------- file_name : str File name (with extension) to oversample found in the specified directory. directory : str Directory where the specified file can be found. An oversampling folder will be created here. N : int, optional Number of points to average together. The default is 100. derivative_limit : float, optional Limit at which oversampling is conducted. A current derivative over this value will result in all data within N/2 points to be kept. The default is 10. adaptive : bool, optional If adaptive sampling is used. Without all data will be over sampled and high derivative points may be missed. The default is True Returns ------- None. \"\"\" oversampled_folder = os . path . join ( directory , 'oversampled' ) if not os . path . isdir ( oversampled_folder ): os . mkdir ( oversampled_folder ) look_forward = int (( N - 1 ) / 2 ) look_back = look_forward + (( N + 1 ) % 2 ) df = pd . read_csv ( os . path . join ( directory , file_name ), skiprows = [ 1 ]) n_points = len ( df ) if not adaptive : ii = 0 idx = list ( range ( ii , look_forward + 1 )) df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_temp [ 'Time' ] = df [ 'Time' ] . iloc [ ii ] df_new = pd . DataFrame ( data = df_temp , columns = df . columns ) ii += N done = False while not done : if ii + look_forward > n_points - 1 : ee = n_points - 1 done = True else : ee = ii + look_forward idx = list ( range ( ii - look_back , ee + 1 )) df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_temp [ 'Time' ] = df [ 'Time' ] . iloc [ ii ] df_new = df_new . append ( df_temp , ignore_index = True ) ii += N if ii >= n_points : done = True else : time = np . array ( df [ 'Time' ]) dT = np . append ( time [ 1 :] - time [: - 1 ], 1 ) current = sum ( np . transpose ( np . array ( df . iloc [:, 52 : 68 ]))) dI = np . append ( current [ 1 :] - current [: - 1 ], 0 ) df = df [ dT != 0 ] dI = dI [ dT != 0 ] dT = dT [ dT != 0 ] derivative = abs ( dI / dT ) n_points = len ( dI ) save_points = np . full ( n_points , False , dtype = bool ) for i in range ( n_points ): if derivative [ i ] > derivative_limit : if i - look_back < 0 : bb = 0 else : bb = i - look_back if i + look_forward > n_points - 1 : ff = n_points - 1 else : ff = i + look_forward idx = list ( range ( bb , ff )) save_points [ idx ] = True df_new = pd . DataFrame ( data = df . iloc [ 0 ], columns = df . columns ) idx = [] for i in range ( 1 , n_points - 1 ): if save_points [ i ]: idx = [ i ] else : if len ( idx ) == 0 : idx = [ i ] else : idx . append ( i ) if ( len ( idx ) == N ) or ( save_points [ i + 1 ] or ( save_points [ i ])): df_temp = pd . DataFrame ( df . iloc [ idx ] . mean ( axis = 0 )) df_temp = df_temp . transpose () df_new = df_new . append ( df_temp , ignore_index = True ) idx = [] df_new [ 'Time' ] = df_new [ 'Time' ] - df_new [ 'Time' ][ 0 ] output_file = os . path . join ( oversampled_folder , file_name ) df_new . to_csv ( output_file , sep = ',' , index = False , float_format = ' %.6g ' ) return","title":"Returns"},{"location":"reference/#liionpack.load_data","text":"Created on Thu Sep 23 10:29:24 2021 @author: Tom","title":"load_data"},{"location":"reference/#liionpack.load_data.load_simulation_data","text":"A bespoke utility function to load in experimental data","title":"load_simulation_data()"},{"location":"reference/#liionpack.load_data.load_simulation_data--parameters","text":"data_dir : str The parent directory for the data file. filename : str, optional The filename for the data. The default is 'A25022021_2_D'.","title":"Parameters"},{"location":"reference/#liionpack.load_data.load_simulation_data--returns","text":"df : pandas.Dataframe An experimental data file Source code in liionpack\\load_data.py def load_simulation_data ( data_dir , filename = 'A25022021_2_D' ): r ''' A bespoke utility function to load in experimental data Parameters ---------- data_dir : str The parent directory for the data file. filename : str, optional The filename for the data. The default is 'A25022021_2_D'. Returns ------- df : pandas.Dataframe An experimental data file ''' df = pd . read_csv ( os . path . join ( data_dir , filename + '.txt' )) # calculate zero currents df = batteryrig_utils . zero_currents ( df ) df = batteryrig_utils . calc_cell_voltages ( df ) st = 172 tmap = df [ 'Time' ] > st df = df [ tmap ] tlow = df [ 'Time' ] . min () df [ 'Time' ] -= tlow df . set_index ( 'Time' , inplace = True , drop = False ) return df","title":"Returns"},{"location":"reference/#liionpack.netlist_utils","text":"Created on Thu Sep 23 10:36:15 2021 @author: Tom","title":"netlist_utils"},{"location":"reference/#liionpack.netlist_utils.read_netlist","text":"Assumes netlist has been saved by LTSpice with format Descriptor Node1 Node2 Value Any lines starting with * are comments and . are commands so ignore them Nodes begin with N so remove that Open ended components are not allowed and their nodes start with NC (no-connection)","title":"read_netlist()"},{"location":"reference/#liionpack.netlist_utils.read_netlist--parameters","text":"filepath : str path to netlist circuit file '.cir'. Ri : float Internal resistance (:math: \\Omega ). The default is 1e-2. Rc : float Connection resistance (:math: \\Omega ). The default is 1e-2. Rb : float Busbar resistance (:math: \\Omega ). The default is 1e-4. Rl : float Long Busbar resistance (:math: \\Omega ). The default is 5e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2.","title":"Parameters"},{"location":"reference/#liionpack.netlist_utils.read_netlist--returns","text":"netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Source code in liionpack\\netlist_utils.py def read_netlist ( filepath , Ri = 1e-2 , Rc = 1e-2 , Rb = 1e-4 , Rl = 5e-4 , I = 80.0 , V = 4.2 ): r ''' Assumes netlist has been saved by LTSpice with format Descriptor Node1 Node2 Value Any lines starting with * are comments and . are commands so ignore them Nodes begin with N so remove that Open ended components are not allowed and their nodes start with NC (no-connection) Parameters ---------- filepath : str path to netlist circuit file '.cir'. Ri : float Internal resistance (:math:`\\Omega`). The default is 1e-2. Rc : float Connection resistance (:math:`\\Omega`). The default is 1e-2. Rb : float Busbar resistance (:math:`\\Omega`). The default is 1e-4. Rl : float Long Busbar resistance (:math:`\\Omega`). The default is 5e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. Returns ------- netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. ''' if '.cir' not in filepath : filepath += '.cir' if not os . path . isfile ( filepath ): temp = os . path . join ( lp . CIRCUIT_DIR , filepath ) if not os . path . isfile ( temp ): pass else : filepath = temp with codecs . open ( filepath , \"r\" , \"utf-16LE\" ) as fd : Lines = fd . readlines () Lines = [ l . strip ( ' \\n ' ) . split ( ' ' ) for l in Lines if l [ 0 ] not in [ '*' , '.' ]] Lines = np . array ( Lines , dtype = '<U16' ) desc = Lines [:, 0 ] N1 = Lines [:, 1 ] N2 = Lines [:, 2 ] # values = Lines[:, 3] values = np . zeros ( len ( N1 )) N1 = np . array ([ x . strip ( 'N' ) for x in N1 ], dtype = int ) N2 = np . array ([ x . strip ( 'N' ) for x in N2 ], dtype = int ) netlist = pd . DataFrame ({ 'desc' : desc , 'node1' : N1 , 'node2' : N2 , 'value' : values }) Ri_map = netlist [ 'desc' ] . str . find ( 'Ri' ) > - 1 Rc_map = netlist [ 'desc' ] . str . find ( 'Rc' ) > - 1 Rb_map = netlist [ 'desc' ] . str . find ( 'Rb' ) > - 1 Rl_map = netlist [ 'desc' ] . str . find ( 'Rl' ) > - 1 V_map = netlist [ 'desc' ] . str . find ( 'V' ) > - 1 I_map = netlist [ 'desc' ] . str . find ( 'I' ) > - 1 netlist . loc [ Ri_map , ( 'value' )] = Ri netlist . loc [ Rc_map , ( 'value' )] = Rc netlist . loc [ Rb_map , ( 'value' )] = Rb netlist . loc [ Rl_map , ( 'value' )] = Rl netlist . loc [ I_map , ( 'value' )] = I netlist . loc [ V_map , ( 'value' )] = V return netlist","title":"Returns"},{"location":"reference/#liionpack.netlist_utils.setup_circuit","text":"Define a netlist from a number of batteries in parallel and series","title":"setup_circuit()"},{"location":"reference/#liionpack.netlist_utils.setup_circuit--parameters","text":"Np : int Number of batteries in parallel. Ns : int Number of batteries in series. Ri : float Internal resistance (:math: \\Omega ). The default is 1e-2. Rc : float Connection resistance (:math: \\Omega ). The default is 1e-2. Rb : float Busbar resistance (:math: \\Omega ). The default is 1e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. plot : bool, optional Plot the circuit. The default is False.","title":"Parameters"},{"location":"reference/#liionpack.netlist_utils.setup_circuit--returns","text":"netlist : TYPE DESCRIPTION. Source code in liionpack\\netlist_utils.py def setup_circuit ( Np , Ns , Ri = 1e-2 , Rc = 1e-2 , Rb = 1e-4 , Rl = 5e-4 , I = 80.0 , V = 4.2 , plot = False ): r ''' Define a netlist from a number of batteries in parallel and series Parameters ---------- Np : int Number of batteries in parallel. Ns : int Number of batteries in series. Ri : float Internal resistance (:math:`\\Omega`). The default is 1e-2. Rc : float Connection resistance (:math:`\\Omega`). The default is 1e-2. Rb : float Busbar resistance (:math:`\\Omega`). The default is 1e-4. I : float Current (A). The default is 80.0. V : float Initial battery voltage (V). The default is 4.2. plot : bool, optional Plot the circuit. The default is False. Returns ------- netlist : TYPE DESCRIPTION. ''' tic = ticker . time () Nc = Np + 1 Nr = Ns * 3 + 1 grid = np . arange ( Nc * Nr ) . reshape ([ Nr , Nc ]) # 1st column is terminals only # 1st and last rows are busbars # Other rows alternate between series resistor and voltage source # Build data with ['element type', Node1, Node2, value] netlist = [] num_Rb = 0 num_I = 0 num_V = 0 desc = [] node1 = [] node2 = [] value = [] # Current source - same end # netline = [] # terminal_nodes = [, ] desc . append ( 'I' + str ( num_I )) num_I += 1 node1 . append ( grid [ 0 , 0 ]) node2 . append ( grid [ - 1 , 0 ]) value . append ( I ) # netlist.append(netline) # Infinite Resistor # netline = [] # terminal_nodes = [grid[0, -1], grid[-1, -1]] # netline.append('R_inf') # netline += terminal_nodes # netline.append(1e6) # netlist.append(netline) # +ve & -ve busbars bus_nodes = [ grid [ - 1 , :], grid [ 0 , :]] for nodes in bus_nodes : for i in range ( len ( nodes ) - 1 ): # netline = [] desc . append ( 'Rb' + str ( num_Rb )) num_Rb += 1 node1 . append ( nodes [ i ]) node2 . append ( nodes [ i + 1 ]) value . append ( Rb ) # netlist.append(netline) num_Rs = 0 num_Ri = 0 # Series resistors and voltage sources cols = np . arange ( Nc )[ 1 :] rows = np . arange ( Nr )[: - 1 ] rtype = [ 'Rs' , 'V' , 'Ri' ] * Ns for col in cols : nodes = grid [:, col ] for row in rows : # netline = [] if rtype [ row ][ 0 ] == 'R' : if rtype [ row ][ 1 ] == 's' : # Series resistor desc . append ( rtype [ row ] + str ( num_Rs )) num_Rs += 1 val = Rc else : # Internal resistor desc . append ( rtype [ row ] + str ( num_Ri )) num_Ri += 1 val = Ri node1 . append ( nodes [ row ]) node2 . append ( nodes [ row + 1 ]) else : # Voltage source desc . append ( 'V' + str ( num_V )) num_V += 1 val = V node1 . append ( nodes [ row + 1 ]) node2 . append ( nodes [ row ]) value . append ( val ) # netlist.append(netline) coords = np . indices ( grid . shape ) y = coords [ 0 , :, :] . flatten () x = coords [ 1 , :, :] . flatten () if plot : plt . figure () # plt.scatter(x, y, c='k') for netline in zip ( desc , node1 , node2 ): elem , n1 , n2 , = netline if elem [ 0 ] == 'I' : color = 'g' elif elem [ 0 ] == 'R' : if elem [ 1 ] == 's' : color = 'r' elif elem [ 1 ] == 'b' : color = 'k' else : color = 'y' elif elem [ 0 ] == 'V' : color = 'b' x1 = x [ n1 ] x2 = x [ n2 ] y1 = y [ n1 ] y2 = y [ n2 ] # print(n1, n2) plt . scatter ([ x1 , x2 ], [ y1 , y2 ], c = 'k' ) plt . plot ([ x1 , x2 ], [ y1 , y2 ], c = color ) desc = np . asarray ( desc ) node1 = np . asarray ( node1 ) node2 = np . asarray ( node2 ) value = np . asarray ( value ) # netlist = np.asarray(netlist, dtype='<U16') node1 , node2 = _make_contiguous ( node1 , node2 ) netlist = pd . DataFrame ({ 'desc' : desc , 'node1' : node1 , 'node2' : node2 , 'value' : value }) toc = ticker . time () print ( 'Setup circuit time' , np . around ( toc - tic , 3 )) return netlist","title":"Returns"},{"location":"reference/#liionpack.netlist_utils.solve_circuit","text":"","title":"solve_circuit()"},{"location":"reference/#liionpack.netlist_utils.solve_circuit--parameters","text":"netlist : TYPE DESCRIPTION.","title":"Parameters"},{"location":"reference/#liionpack.netlist_utils.solve_circuit--returns","text":"None. Source code in liionpack\\netlist_utils.py def solve_circuit ( netlist ): r ''' Parameters ---------- netlist : TYPE DESCRIPTION. Returns ------- None. ''' tic = ticker . time () # Name = netlist[:, 0] # element names # N1 = netlist[:, 1].astype(int) # Node numbers # N2 = netlist[:, 2].astype(int) # arg3 = netlist[:, 3].astype(float) # Values Name = np . array ( netlist [ 'desc' ]) . astype ( '<U16' ) N1 = np . array ( netlist [ 'node1' ]) N2 = np . array ( netlist [ 'node2' ]) arg3 = np . array ( netlist [ 'value' ]) n = np . concatenate (( N1 , N2 )) . max () # Highest node number nLines = netlist . shape [ 0 ] m = 0 # \"m\" is the number of voltage sources, determined below. V_elem = [ 'V' , 'O' , 'E' , 'H' ] for nm in Name : if nm [ 0 ] in V_elem : m += 1 G = np . zeros ([ n , n ]) B = np . zeros ([ n , m ]) D = np . zeros ([ m , m ]) i = np . zeros ([ n , 1 ]) e = np . zeros ([ m , 1 ]) \"\"\" % We need to keep track of the number of voltage sources we've parsed % so far as we go through file. We start with zero. \"\"\" vsCnt = 0 \"\"\" % This loop does the bulk of filling in the arrays. It scans line by line % and fills in the arrays depending on the type of element found on the % current line. % See http://lpsa.swarthmore.edu/Systems/Electrical/mna/MNA3.html \"\"\" for k1 in range ( nLines ): n1 = N1 [ k1 ] - 1 # get the two node numbers in python index format n2 = N2 [ k1 ] - 1 elem = Name [ k1 ][ 0 ] if elem == 'R' : g = 1 / arg3 [ k1 ] # conductance = 1 / R \"\"\" % Here we fill in G array by adding conductance. % The procedure is slightly different if one of the nodes is % ground, so check for those accordingly. \"\"\" if n1 == - 1 : # -1 is the ground node G [ n2 , n2 ] = G [ n2 , n2 ] + g elif n2 == - 1 : G [ n1 , n1 ] = G [ n1 , n1 ] + g else : G [ n1 , n1 ] = G [ n1 , n1 ] + g G [ n2 , n2 ] = G [ n2 , n2 ] + g G [ n1 , n2 ] = G [ n1 , n2 ] - g G [ n2 , n1 ] = G [ n2 , n1 ] - g elif elem == 'V' : if n1 >= 0 : B [ n1 , vsCnt ] = B [ n1 , vsCnt ] + 1 if n2 >= 0 : B [ n2 , vsCnt ] = B [ n2 , vsCnt ] - 1 e [ vsCnt ] = arg3 [ k1 ] vsCnt += 1 elif elem == 'I' : if n1 >= 0 : i [ n1 ] = i [ n1 ] - arg3 [ k1 ] if n2 >= 0 : i [ n2 ] = i [ n2 ] + arg3 [ k1 ] upper = np . hstack (( G , B )) lower = np . hstack (( B . T , D )) A = np . vstack (( upper , lower )) z = np . vstack (( i , e )) X = solve ( A , z ) . flatten () # include ground node V_node = np . zeros ( n + 1 ) V_node [ 1 :] = X [: n ] I_batt = X [ n :] # print(X) toc = ticker . time () print ( 'Solve circuit time' , np . around ( toc - tic , 3 )) return V_node , I_batt","title":"Returns"},{"location":"reference/#liionpack.protocols","text":"Created on Thu Sep 23 14:44:19 2021 @author: Tom","title":"protocols"},{"location":"reference/#liionpack.protocols.generate_protocol","text":"","title":"generate_protocol()"},{"location":"reference/#liionpack.protocols.generate_protocol--parameters","text":"I_dch : float Negative discharge current [A]. The default is -50. I_chg : float Positive charge current [A]. The default is 50. t_dch : int number of time steps to discharge. The default is 180. t_chg : int number of time steps to charge. The default is 180. t_rest : int, optional number of time steps to rest inbetween charge and discharge. The default is 90. chg_first : bool charge before discharge. The default is True","title":"Parameters"},{"location":"reference/#liionpack.protocols.generate_protocol--returns","text":"proto : list a sequence of terminal currents to apply at each timestep Source code in liionpack\\protocols.py def generate_protocol ( I_dch =- 50 , I_chg = 50 , t_dch = 180 , t_chg = 180 , t_rest = 90 , chg_first = True ): r ''' Parameters ---------- I_dch : float Negative discharge current [A]. The default is -50. I_chg : float Positive charge current [A]. The default is 50. t_dch : int number of time steps to discharge. The default is 180. t_chg : int number of time steps to charge. The default is 180. t_rest : int, optional number of time steps to rest inbetween charge and discharge. The default is 90. chg_first : bool charge before discharge. The default is True Returns ------- proto : list a sequence of terminal currents to apply at each timestep ''' if chg_first : proto = [ I_chg ] * t_chg + [ 0.0 ] * t_rest + [ I_dch ] * t_dch + [ 0.0 ] * t_rest else : proto = [ I_dch ] * t_dch + [ 0.0 ] * t_rest + [ I_chg ] * t_chg + [ 0.0 ] * t_rest return proto","title":"Returns"},{"location":"reference/#liionpack.protocols.test_protocol","text":"retun a simple test protocol with no options","title":"test_protocol()"},{"location":"reference/#liionpack.protocols.test_protocol--returns","text":"proto : list a test sequence of terminal currents to apply at each timestep. Source code in liionpack\\protocols.py def test_protocol (): r ''' retun a simple test protocol with no options Returns ------- proto : list a test sequence of terminal currents to apply at each timestep. ''' return generate_protocol ( I_dch =- 50 , I_chg = 50 , t_dch = 30 , t_chg = 30 , t_rest = 15 )","title":"Returns"},{"location":"reference/#liionpack.sim_utils","text":"Created on Thu Sep 23 10:41:16 2021 @author: Tom","title":"sim_utils"},{"location":"reference/#liionpack.sim_utils.create_init_funcs","text":"","title":"create_init_funcs()"},{"location":"reference/#liionpack.sim_utils.create_init_funcs--parameters","text":"parameter_values : TYPE, optional DESCRIPTION. The default is None.","title":"Parameters"},{"location":"reference/#liionpack.sim_utils.create_init_funcs--returns","text":"None. Source code in liionpack\\sim_utils.py def create_init_funcs ( parameter_values = None ): r ''' Parameters ---------- parameter_values : TYPE, optional DESCRIPTION. The default is None. Returns ------- None. ''' V_upper_limit = parameter_values [ 'Upper voltage cut-off [V]' ] V_lower_limit = parameter_values [ 'Lower voltage cut-off [V]' ] # Make sure we slow charge to upper limit and establish equilibrium experiment = pybamm . Experiment ( [ f \"Charge at C/50 until { V_upper_limit } V (10 second period)\" , f \"Hold at { V_upper_limit } V until 0.5mA (10 second period)\" , \"Rest for 30 minutes (1 minute period)\" , f \"Discharge at C/100 until { V_lower_limit } V (1 minute period)\" , ] ) # sim.set_up_experiment(model, experiment) # sim = pybamm.Simulation(model=model, parameter_values=param, experiment=experiment) sim = lp . create_simulation ( parameter_values = parameter_values , experiment = experiment ) sim . solve () # sim.plot() # param = sim.parameter_values # Save concentrations for initial conditions neg_surf = 'X-averaged negative particle surface concentration [mol.m-3]' pos_surf = 'X-averaged positive particle surface concentration [mol.m-3]' sol_charged = sim . solution . cycles [ 2 ] v_upper_lim_neg = sol_charged [ neg_surf ] . entries [ - 1 ] v_upper_lim_pos = sol_charged [ pos_surf ] . entries [ - 1 ] # Save lower concentrations sol_dischg = sim . solution . cycles [ 3 ] v_lower_lim_neg = sol_dischg [ neg_surf ] . entries [ - 1 ] v_lower_lim_pos = sol_dischg [ pos_surf ] . entries [ - 1 ] # Use max conc. for normalization c_s_n_max = parameter_values [ 'Maximum concentration in negative electrode [mol.m-3]' ] c_s_p_max = parameter_values [ 'Maximum concentration in positive electrode [mol.m-3]' ] # These are now the min and max concs for full range of SoC x_n_max = v_upper_lim_neg / c_s_n_max x_p_min = v_upper_lim_pos / c_s_p_max x_n_min = v_lower_lim_neg / c_s_n_max x_p_max = v_lower_lim_pos / c_s_p_max # Work out total capacity between voltage lims current = sol_dischg [ 'Current [A]' ] . entries time = sol_dischg [ 'Time [h]' ] . entries dt = time [ 1 :] - time [: - 1 ] c_ave = ( current [ 1 :] + current [: - 1 ]) / 2 charge = np . cumsum ( c_ave * dt ) plt . figure () plt . plot ( time [ 1 :], charge ) plt . xlabel ( 'Time [h]' ) plt . ylabel ( 'Cumulative Charge Transferred [Ah]' ) SoC = np . linspace ( 0 , 1 , 1000 ) x_n = x_n_min + ( x_n_max - x_n_min ) * SoC x_p = x_p_max - ( x_p_max - x_p_min ) * SoC try : # Ocp are functions U_n = parameter_values [ 'Negative electrode OCP [V]' ] U_p = parameter_values [ 'Positive electrode OCP [V]' ] U_n_eval = parameter_values . evaluate ( U_n ( pybamm . Array ( x_n ))) U_p_eval = parameter_values . evaluate ( U_p ( pybamm . Array ( x_p ))) OCV = U_p_eval - U_n_eval OCV = OCV . flatten () except : # Ocp is data # Get the OCP data and plot it from the parameters neg_ocp = parameter_values [ 'Negative electrode OCP [V]' ][ 1 ] pos_ocp = parameter_values [ 'Positive electrode OCP [V]' ][ 1 ] # Split the data neg_x = neg_ocp [:, 0 ] neg_y = neg_ocp [:, 1 ] pos_x = pos_ocp [:, 0 ] pos_y = pos_ocp [:, 1 ] # plt.figure() # plt.plot(neg_x, neg_y) # plt.title('Neg OCP') # plt.ylabel('OCP [V]') # plt.xlabel('Lithiation') # plt.figure() # plt.plot(pos_x, pos_y) # plt.title('Pos OCP') # plt.ylabel('OCP [V]') # plt.xlabel('Lithiation') # interpolant functions U_n = interp1d ( neg_x , neg_y ) U_p = interp1d ( pos_x , pos_y ) # OCV theoretical based on discharge at eqm OCV = U_p ( x_p ) - U_n ( x_n ) # Compare to C/100 plt . figure () plt . plot ( SoC , OCV ) plt . ylabel ( 'OCP [V]' ) plt . xlabel ( 'SoC' ) terminal = sol_dischg [ 'Terminal voltage [V]' ] . entries plt . plot ( np . linspace ( 0.0 , 1.0 , len ( terminal ))[:: - 1 ], terminal , 'r--' ) # Reverse interpolants to get back lithiation states from SoC and OCV x_n_SoC = interp1d ( SoC , x_n ) x_p_SoC = interp1d ( SoC , x_p ) x_n_OCV = interp1d ( OCV , x_n ) x_p_OCV = interp1d ( OCV , x_p ) vmin = float ( V_lower_limit ) vmax = float ( V_upper_limit ) init_funcs = { 'x_n_SoC' : x_n_SoC , 'x_p_SoC' : x_p_SoC , 'x_n_OCV' : x_n_OCV , 'x_p_OCV' : x_p_OCV , 'c_s_n_max' : c_s_n_max , 'c_s_p_max' : c_s_p_max , 'vmin' : vmin , 'vmax' : vmax } with open ( init_fname , 'wb' ) as handle : pickle . dump ( init_funcs , handle )","title":"Returns"},{"location":"reference/#liionpack.sim_utils.initial_conditions","text":"","title":"initial_conditions()"},{"location":"reference/#liionpack.sim_utils.initial_conditions--parameters","text":"SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1.","title":"Parameters"},{"location":"reference/#liionpack.sim_utils.initial_conditions--returns","text":"c_s_n_init : TYPE DESCRIPTION. c_s_p_init : TYPE DESCRIPTION. Source code in liionpack\\sim_utils.py def initial_conditions ( SoC =- 1 , OCV =- 1 ): r ''' Parameters ---------- SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns ------- c_s_n_init : TYPE DESCRIPTION. c_s_p_init : TYPE DESCRIPTION. ''' with open ( init_fname , 'rb' ) as handle : init_funcs = pickle . load ( handle ) x_n_SoC = init_funcs [ 'x_n_SoC' ] x_p_SoC = init_funcs [ 'x_p_SoC' ] x_n_OCV = init_funcs [ 'x_n_OCV' ] x_p_OCV = init_funcs [ 'x_p_OCV' ] c_s_n_max = init_funcs [ 'c_s_n_max' ] c_s_p_max = init_funcs [ 'c_s_p_max' ] vmin = init_funcs [ 'vmin' ] vmax = init_funcs [ 'vmax' ] if SoC >= 0.0 and SoC <= 1.0 : x_n_init = x_n_SoC ( SoC ) x_p_init = x_p_SoC ( SoC ) elif OCV >= vmin and OCV <= vmax : x_n_init = x_n_OCV ( OCV ) x_p_init = x_p_OCV ( OCV ) c_s_n_init = x_n_init * c_s_n_max c_s_p_init = x_p_init * c_s_p_max return c_s_n_init , c_s_p_init","title":"Returns"},{"location":"reference/#liionpack.sim_utils.update_init_conc","text":"","title":"update_init_conc()"},{"location":"reference/#liionpack.sim_utils.update_init_conc--parameters","text":"sim : TYPE DESCRIPTION. SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1.","title":"Parameters"},{"location":"reference/#liionpack.sim_utils.update_init_conc--returns","text":"None. Source code in liionpack\\sim_utils.py def update_init_conc ( sim , SoC =- 1 , OCV =- 1 ): r ''' Parameters ---------- sim : TYPE DESCRIPTION. SoC : TYPE, optional DESCRIPTION. The default is -1. OCV : TYPE, optional DESCRIPTION. The default is -1. Returns ------- None. ''' param = sim . parameter_values c_s_n_init , c_s_p_init = initial_conditions ( SoC = SoC , OCV = OCV ) param . update ({ \"Initial concentration in negative electrode [mol.m-3]\" : c_s_n_init , \"Initial concentration in positive electrode [mol.m-3]\" : c_s_p_init , })","title":"Returns"},{"location":"reference/#liionpack.simulations","text":"Created on Wed Sep 22 15:37:51 2021 @author: tom","title":"simulations"},{"location":"reference/#liionpack.simulations.create_simulation","text":"Create a PyBaMM simulation set up for interation with liionpack","title":"create_simulation()"},{"location":"reference/#liionpack.simulations.create_simulation--parameters","text":"parameter_values : pybamm.ParameterValues class DESCRIPTION. The default is None. experiment : pybamm.Experiment class DESCRIPTION. The default is None. make_inputs : bool, optional Changes \"Current function [A]\" and \"Total heat transfer coefficient [W.m-2.K-1]\" to be inputs that are controlled by liionpack. The default is False.","title":"Parameters"},{"location":"reference/#liionpack.simulations.create_simulation--returns","text":"sim : pybamm.Simulation A simulation that can be solved individually or passed into the liionpack solve method Source code in liionpack\\simulations.py def create_simulation ( parameter_values = None , experiment = None , make_inputs = False ): r ''' Create a PyBaMM simulation set up for interation with liionpack Parameters ---------- parameter_values : pybamm.ParameterValues class DESCRIPTION. The default is None. experiment : pybamm.Experiment class DESCRIPTION. The default is None. make_inputs : bool, optional Changes \"Current function [A]\" and \"Total heat transfer coefficient [W.m-2.K-1]\" to be inputs that are controlled by liionpack. The default is False. Returns ------- sim : pybamm.Simulation A simulation that can be solved individually or passed into the liionpack solve method ''' # Create the pybamm model model = pybamm . lithium_ion . SPMe ( options = { \"thermal\" : \"lumped\" , # \"external submodels\": [\"thermal\"], }) # geometry = model.default_geometry if parameter_values is None : # load parameter values and process model and geometry chemistry = pybamm . parameter_sets . Chen2020 param = pybamm . ParameterValues ( chemistry = chemistry ) # Change the current function to be an input as this is set by the external circuit if make_inputs : parameter_values . update ({ \"Current function [A]\" : _current_function ,}) parameter_values . update ({ \"Current\" : \"[input]\" , \"Total heat transfer coefficient [W.m-2.K-1]\" : \"[input]\" }, check_already_exists = False ) solver = pybamm . CasadiSolver ( mode = 'safe' ) sim = pybamm . Simulation ( model = model , experiment = experiment , parameter_values = parameter_values , solver = solver ) return sim","title":"Returns"},{"location":"reference/#liionpack.solver_utils","text":"Created on Thu Sep 23 10:44:31 2021 @author: Tom","title":"solver_utils"},{"location":"reference/#liionpack.solver_utils.solve","text":"Solves a pack simulation","title":"solve()"},{"location":"reference/#liionpack.solver_utils.solve--parameters","text":"netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Produced by liionpack.read_netlist or liionpack.setup_circuit parameter_values : pybamm.ParameterValues class A dictionary of all the model parameters proto : list a sequence of terminal currents to apply at each timestep. Produced by liionpack.generate_protocol dt : float, optional Time interval for a single step [s]. The default is 10. I_init : float, optional Initial guess for single battery current [A]. The default is 1.0. htc : float array, optional Heat transfer coefficient array of length Nspm. The default is None. nproc : int, optional Number of processes to start in parallel for mapping. The default is 12. output_variables : list, optional Variables to evaluate during solve. Must be a valid key in the model.variables","title":"Parameters"},{"location":"reference/#liionpack.solver_utils.solve--raises","text":"Exception DESCRIPTION.","title":"Raises"},{"location":"reference/#liionpack.solver_utils.solve--returns","text":"output : ndarray shape [# variable, # steps, # batteries] simulation output array Source code in liionpack\\solver_utils.py def solve ( netlist = None , parameter_values = None , protocol = None , dt = 10 , I_init = 1.0 , htc = None , nproc = 12 , output_variables = None ): r ''' Solves a pack simulation Parameters ---------- netlist : pandas.DataFrame A netlist of circuit elements with format. desc, node1, node2, value. Produced by liionpack.read_netlist or liionpack.setup_circuit parameter_values : pybamm.ParameterValues class A dictionary of all the model parameters proto : list a sequence of terminal currents to apply at each timestep. Produced by liionpack.generate_protocol dt : float, optional Time interval for a single step [s]. The default is 10. I_init : float, optional Initial guess for single battery current [A]. The default is 1.0. htc : float array, optional Heat transfer coefficient array of length Nspm. The default is None. nproc : int, optional Number of processes to start in parallel for mapping. The default is 12. output_variables : list, optional Variables to evaluate during solve. Must be a valid key in the model.variables Raises ------ Exception DESCRIPTION. Returns ------- output : ndarray shape [# variable, # steps, # batteries] simulation output array ''' if netlist is None or parameter_values is None or protocol is None : raise Exception ( 'Please supply a netlist, paramater_values and protocol' ) # Get netlist indices for resistors, voltage sources, current sources Ri_map = netlist [ 'desc' ] . str . find ( 'Ri' ) > - 1 V_map = netlist [ 'desc' ] . str . find ( 'V' ) > - 1 I_map = netlist [ 'desc' ] . str . find ( 'I' ) > - 1 Nspm = np . sum ( V_map ) Nsteps = len ( protocol ) # Solve the circuit to initialise the electrochemical models V_node , I_batt = lp . solve_circuit ( netlist ) sim = lp . create_simulation ( parameter_values , make_inputs = True ) lp . update_init_conc ( sim , SoC = 0.14 ) v_cut_lower = parameter_values [ 'Lower voltage cut-off [V]' ] v_cut_higher = parameter_values [ 'Upper voltage cut-off [V]' ] # The simulation output variables calculated at each step for each battery # Must be a 0D variable i.e. battery wide volume average - or X-averaged for 1D model variable_names = [ 'Terminal voltage [V]' , 'Measured battery open circuit voltage [V]' , 'Local ECM resistance [Ohm]' ] if output_variables is not None : for out in output_variables : if out not in variable_names : variable_names . append ( out ) # variable_names = variable_names + output_variables Nvar = len ( variable_names ) # Storage variables for simulation data shm_i_app = np . zeros ([ Nsteps , Nspm ], dtype = float ) shm_Ri = np . zeros ([ Nsteps , Nspm ], dtype = float ) output = np . zeros ([ Nvar , Nsteps , Nspm ], dtype = float ) # Initialize currents in battery models shm_i_app [ 0 , :] = I_batt * - 1 time = 0 step = 0 end_time = dt * Nsteps step_solutions = [ None ] * Nspm V_terminal = [] record_times = [] integrator , variables_fn , t_eval = _create_casadi_objects ( I_init , htc [ 0 ], sim , dt , Nspm , nproc , variable_names ) sim_start_time = ticker . time () while time < end_time : print ( step , 'Time' , time ) tic = ticker . time () step_solutions , var_eval = _mapped_step ( sim . built_model , step_solutions , lp . build_inputs_dict ( shm_i_app [ step , :], htc ), integrator , variables_fn , t_eval ) output [:, step , :] = var_eval time += dt # Calculate internal resistance and update netlist temp_v = output [ 0 , step , :] temp_ocv = output [ 1 , step , :] temp_Ri = np . abs ( output [ 2 , step , :]) shm_Ri [ step , :] = temp_Ri netlist . loc [ V_map , ( 'value' )] = temp_ocv netlist . loc [ Ri_map , ( 'value' )] = temp_Ri netlist . loc [ I_map , ( 'value' )] = protocol [ step ] print ( 'Stepping time' , np . around ( ticker . time () - tic , 2 ), 's' ) if np . any ( temp_v < v_cut_lower ): print ( 'Low V limit reached' ) break if np . any ( temp_v > v_cut_higher ): print ( 'High V limit reached' ) break step += 1 if time < end_time : record_times . append ( time ) V_node , I_batt = lp . solve_circuit ( netlist ) shm_i_app [ step , :] = I_batt [:] * - 1 V_terminal . append ( V_node . max ()) # Plots colors = plt . cm . jet ( np . linspace ( 0 , 1 , Nspm )) plt . figure () for i in range ( Nspm ): plt . plot ( shm_i_app [ 1 : step , i ], color = colors [ i ]) plt . title ( 'Currents' ) for j in range ( Nvar ): plt . figure () for i in range ( Nspm ): plt . plot ( output [ j , 1 : step , i ], color = colors [ i ]) plt . title ( variable_names [ j ]) plt . figure () plt . plot ( record_times , V_terminal , label = 'simulation' ) plt . title ( 'Pack terminal voltage [V]' ) plt . legend () toc = ticker . time () print ( 'Solve circuit time' , np . around ( toc - sim_start_time , 3 )) return output","title":"Returns"},{"location":"reference/#liionpack.utils","text":"Created on Thu Sep 23 10:33:13 2021 @author: Tom","title":"utils"},{"location":"reference/#liionpack.utils.build_inputs_dict","text":"Function to convert inputs and external_variable arrays to list of dicts As expected by the casadi solver. These are then converted back for mapped solving but stored individually on each returned solution. Can probably remove this process later","title":"build_inputs_dict()"},{"location":"reference/#liionpack.utils.build_inputs_dict--parameters","text":"I_batt : float array The input current for each battery. htc : float array the heat transfer coefficient for each battery.","title":"Parameters"},{"location":"reference/#liionpack.utils.build_inputs_dict--returns","text":"inputs_dict : list each element of the list is an inputs dictionary corresponding to each battery. Source code in liionpack\\utils.py def build_inputs_dict ( I_batt , htc ): r ''' Function to convert inputs and external_variable arrays to list of dicts As expected by the casadi solver. These are then converted back for mapped solving but stored individually on each returned solution. Can probably remove this process later Parameters ---------- I_batt : float array The input current for each battery. htc : float array the heat transfer coefficient for each battery. Returns ------- inputs_dict : list each element of the list is an inputs dictionary corresponding to each battery. ''' inputs_dict = [] for i in range ( len ( I_batt )): inputs_dict . append ({ # 'Volume-averaged cell temperature': T_batt[i], \"Current\" : I_batt [ i ], \"Total heat transfer coefficient [W.m-2.K-1]\" : htc [ i ], }) return inputs_dict","title":"Returns"},{"location":"reference/#liionpack.utils.get_interpolated_htc","text":"A very bespoke function that is called in the solve process to update the heat transfer coefficients for every battery","title":"get_interpolated_htc()"},{"location":"reference/#liionpack.utils.get_interpolated_htc--parameters","text":"funcs : list each element of the list is an interpolant function. T : float array The temperature of each battery. Q : float The flow rate for the system.","title":"Parameters"},{"location":"reference/#liionpack.utils.get_interpolated_htc--returns","text":"htc : float Heat transfer coefficient for each battery. Source code in liionpack\\utils.py def get_interpolated_htc ( funcs , T , Q ): r ''' A very bespoke function that is called in the solve process to update the heat transfer coefficients for every battery Parameters ---------- funcs : list each element of the list is an interpolant function. T : float array The temperature of each battery. Q : float The flow rate for the system. Returns ------- htc : float Heat transfer coefficient for each battery. ''' ncell = len ( T ) htc = np . zeros ( ncell ) for i in range ( ncell ): htc [ i ] = funcs [ i ]( T [ i ], Q ) return htc","title":"Returns"},{"location":"reference/#liionpack.utils.interp_current","text":"Returns an interpolation function for current w.r.t time","title":"interp_current()"},{"location":"reference/#liionpack.utils.interp_current--parameters","text":"df : pandas.DataFrame or Dict Contains data for 'Time' and 'Cells Total Current' from which to construct an interpolant function","title":"Parameters"},{"location":"reference/#liionpack.utils.interp_current--returns","text":"f : function interpolant function of total cell current with time. Source code in liionpack\\utils.py def interp_current ( df ): r ''' Returns an interpolation function for current w.r.t time Parameters ---------- df : pandas.DataFrame or Dict Contains data for 'Time' and 'Cells Total Current' from which to construct an interpolant function Returns ------- f : function interpolant function of total cell current with time. ''' t = df [ 'Time' ] I = df [ 'Cells Total Current' ] f = interp1d ( t , I ) return f","title":"Returns"},{"location":"reference/#liionpack.utils.read_cfd_data","text":"A very bespoke function to read heat transfer coefficients from an excel file","title":"read_cfd_data()"},{"location":"reference/#liionpack.utils.read_cfd_data--parameters","text":"data_dir : str, optional Path to data file. The default is None. If unspecified the module liionpack.DATA_DIR folder will be used filename : str, optional DESCRIPTION. The default is 'cfd_data.xlsx'.","title":"Parameters"},{"location":"reference/#liionpack.utils.read_cfd_data--returns","text":"funcs : list an interpolant is returned for each cell in the excel file. Source code in liionpack\\utils.py def read_cfd_data ( data_dir = None , filename = 'cfd_data.xlsx' ): r ''' A very bespoke function to read heat transfer coefficients from an excel file Parameters ---------- data_dir : str, optional Path to data file. The default is None. If unspecified the module liionpack.DATA_DIR folder will be used filename : str, optional DESCRIPTION. The default is 'cfd_data.xlsx'. Returns ------- funcs : list an interpolant is returned for each cell in the excel file. ''' if data_dir is None : data_dir = liionpack . DATA_DIR fpath = os . path . join ( data_dir , filename ) ncells = 32 flow_bps = np . array ( pd . read_excel ( fpath , sheet_name = 'massflow_bps' , header = None )) temp_bps = np . array ( pd . read_excel ( fpath , sheet_name = 'temperature_bps' , header = None )) xv , yv = np . meshgrid ( temp_bps , flow_bps ) data = np . zeros ([ len ( temp_bps ), len ( flow_bps ), ncells ]) funcs = [] for i in range ( ncells ): data [:, :, i ] = np . array ( pd . read_excel ( fpath , sheet_name = 'cell' + str ( i + 1 ), header = None )) funcs . append ( interp2d ( xv , yv , data [:, :, i ], kind = 'linear' )) return funcs","title":"Returns"}]}